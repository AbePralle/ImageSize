#================================================================================
# ImageSize.rogue
# April 27, 2021
#================================================================================

$requireRogue "1.8.1"

uses Utility/CommandLineParser
uses Bitmap
uses Geometry

try
  ImageSize( System.command_line_arguments )
catch (error:Error)
  local w = Console.width.or_smaller( 80 )
  Console.error.println "="*w
  Console.error.println "ERROR"
  Console.error.println error->String.word_wrapped(w-2).indented(2)
  Console.error.println "="*w
  System.exit 1
endTry

class ImageSize
  PROPERTIES
    input_filepaths = String[]
    commands        = Command[]
    output_command  : Command

  METHODS
    method init( args:String[] )
      local command = CommandLineParser().
      [
        option( "--output=",  &alias="-o" )
        on_unknown( this=>show_usage )
      ].parse( System.command_line_arguments )

      if (command//args.is_empty)
        show_usage
        System.exit
      endIf

      commands.add( CmdPrintInfo() )

      local reader = command//args.to_list<<String>>.reader
      forEach (arg in reader)
        if (arg == "resize")
          commands.add( CmdResize(read_w_h("resize",reader)) )
        elseIf (arg == "crop")
          commands.add( CmdCrop(read_w_h("crop",reader)) )
        elseIf (arg == "aspect")
          contingent
            necessary (reader.has_another)
            local is_fit = false
            which (reader.read)
              case "fit":  is_fit = true
              case "fill": noAction
              others:      necessary (false)
            endWhich
            commands.add( CmdAspect(read_aspect_w_h(reader),is_fit) )
          unsatisfied
            error( "Expected 'fill' or 'fit' after 'aspect'." )
          endContingent
        elseIf (arg == "anchor")
          commands.add( CmdSetAnchor(read_anchor_args(reader)) )
        elseIf (arg == "replace")
          output_command = CmdSaveReplace()
        else
          input_filepaths.add( arg )
        endIf
      endForEach

      if (not output_command and commands.count > 1)
        if (command//options//output)
          output_command = CmdSave( command//options//output->String )
        else
          output_command = CmdSave( "{name}-{w}x{h}.{ext}" )
        endIf
      endIf

      forEach (filepath in input_filepaths)
        Command.anchor_x = 0.5
        Command.anchor_y = 0.5
        local bitmap = Bitmap( File(filepath) )
        if (bitmap.error) error( ''Error loading "$".''(filepath) )
        forEach (cmd in commands)
          bitmap = cmd( bitmap )
        endForEach
        if (output_command) output_command( bitmap )
      endForEach

    method error( message:String )
      Console.error.println "ERROR: " + message
      System.exit 1

    method read_w_h( cmd_name:String, reader:Reader<<String>> )->XY
      if (reader.has_another)
        local param = reader.read
        if (param.contains('x'))
          local parts = param.split( 'x' )
          if (parts[0].count)
            if (parts[1].count) return XY(parts[0]->Int32,parts[1]->Int32)
            else                return XY(parts[0]->Int32,0)
          else
            if (parts[1].count) return XY(0,parts[1]->Int32)
          endIf
        endIf
      endIf

      error( ''Expected 'WxH', 'Wx', or 'xH' after '$'.''(cmd_name) )
      return XY.zero

    method read_aspect_w_h( reader:Reader<<String>> )->XY
      if (reader.has_another)
        local param = reader.read
        if (param.contains('x'))
          local parts = param.split( 'x' )
          if (parts[0].count)
            if (parts[1].count) return XY(parts[0]->Int32,parts[1]->Int32)
          endIf
        endIf
      endIf

      error( ''Expected 'WxH' after 'aspect fill/fit'.'' )
      return XY.zero

    method read_anchor_args( reader:Reader<<String>> )->XY
      block
        if (reader.has_another)
          if (reader.peek.contains('x'))
            local parts = reader.read.split( 'x' )
            if (parts[0].count)
              if (parts[1].count) return XY(parts[0]->Int32,parts[1]->Int32)
            endIf
            escapeBlock
          endIf

          local x = 0.5
          local y = 0.5
          while (reader.has_another)
            which (reader.peek.to_lowercase)
              case "left":   reader.read; x = 0.0
              case "right":  reader.read; x = 1.0
              case "top":    reader.read; y = 0.0
              case "bottom": reader.read; y = 1.0
              case "center": reader.read; x = 0.5; y = 0.5
              others:        escapeWhile
            endWhich
          endWhile
          return XY(x,y)
        endIf
      endBlock

      error( ''Expected 'WxH' or one or more of [left,top,right,bottom,center] after 'anchor'.'' )
      return XY.zero

    method show_usage
      println @|USAGE
               |  imagesize <input-patterns> [options] [--output=<output-pattern> | replace]
               |
               |INPUT PATTERNS
               |  path/to/file
               |  *.jpg
               |  "**/*.png"
               |
               |OPTIONS
               |  resize  [WxH | Wx | xH]
               |    Resizes image to specified pixel width and height. Uses a filtering effect
               |    when downsizing or when upsizing and not a whole multiple of the original
               |    size. Can specify width-only (Wx) and auto-calculate height from the aspect
               |    ratio or vice versa.
               |
               |  crop [WxH | Wx | xH]
               |    Crops or expands the canvas. The anchor point is CENTER by default and can
               |    be changed with a preceding 'anchor' command. 'crop Wx' and 'crop xH'
               |    change the width or height of one dimension but not the other.
               |
               |  aspect [fill | fit]  [WxH]
               |    Crops the image to fit a given aspect ratio. 'aspect 1024x768' has the
               |    same effect as 'aspect 4x3'. 'aspect' uses the anchor specified by the
               |    preceding 'anchor' command or CENTER by default.
               |
               |  anchor [WxH]
               |  anchor [left | right | top | bottom | center]
               |    Specifies the anchor used by successive 'crop' and 'aspect fill/fit'.
               |    commands. Either proportional values (0.0=left/top, 0.5=center,
               |    1.0=right/bottom) or positional names may be used ('anchor top left',
               |    'anchor left', etc.
               |
               |  flip | hflip | vflip
               |    Flips (mirrors) an image horizontally or vertically.
               |
               |  rotate [-90|90|180|cw|ccw]
               |    Rotates the image 90 degrees (clockwise), -90 degrees (counter-clockwise),
               |    or 180 degrees.
               |
               |OUTPUT PATTERN
               |  path
               |  path/to/file[.png/.jpg/.jpeg] # Specify .png etc. to output in that format
               |  filepath-with-{placeholders}
               |  replace # overwrites source images
               |
               |OUTPUT PATTERN PLACEHOLDERS
               |  {path}      - The original path without the filename.
               |  {filename}  - The original filename+extension without the path.
               |  {name}      - The original filename without the path or extension.
               |  {ext}       - The extension of the original filename.
               |  {001}       - The sequence number (number of images written out so far). Use
               |                {001} for a minimum 3 digits starting at 001, {50} for a
               |                minimum 2 digits starting at 50, etc.
               |  {w}, {h}    - The width or height of the output image.
               |
               |EXAMPLES
               |  imagesize Screenshots/* aspect fill 4x3 resize 320x200 -o "Thumbnails/{name}.jpg"
endClass

class Command [abstract]
  GLOBAL PROPERTIES
    anchor_x = 0.5
    anchor_y = 0.5

  METHODS
    method anchor->Anchor
      return Anchor( XY(anchor_x,anchor_y) )

    method call( bitmap:Bitmap )->Bitmap [abstract]
      noAction
endClass

class CmdPrintInfo : Command
  METHODS
    method call( bitmap:Bitmap )->Bitmap
      println "$ [$x$]" (bitmap.filepath,bitmap.width,bitmap.height)
      return bitmap
endClass

class CmdResize( new_size:XY ) : Command
  METHODS
    method call( bitmap:Bitmap )->Bitmap
      local new_size = new_size
      local w = bitmap.width
      local h = bitmap.height
      if (new_size.x == 0)     new_size = XY( w*(new_size.y/h), new_size.y )
      elseIf (new_size.y == 0) new_size = XY( new_size.x, h*(new_size.x/w) )
      w = new_size.x
      h = new_size.y
      println "  resize [$x$]" (w,h)
      bitmap.resize( w, h )
      return bitmap
endClass

class CmdCrop( new_size:XY ) : Command
  METHODS
    method call( bitmap:Bitmap )->Bitmap
      local w = bitmap.width
      local h = bitmap.height
      if (new_size.x) w = new_size.x
      if (new_size.y) h = new_size.y
      println "  crop [$x$]" (w,h)
      bitmap.crop( w, h, anchor, Color.BLACK )
      return bitmap
endClass

class CmdAspect( new_size:XY, is_fit:Logical ) : Command
  METHODS
    method call( bitmap:Bitmap )->Bitmap
      local w = bitmap.width
      local h = bitmap.height
      local adjusted_height = (w / new_size.x) * new_size.y : Int32
      local adjusted_width  = (h / new_size.y) * new_size.x : Int32

      println "  aspect $ [$x$]" (which{is_fit:"fit"||"fill"},new_size.x->Int32,new_size.y->Int32)
      if (is_fit)
        if (adjusted_width < w) bitmap.crop( w, adjusted_height, anchor, Color.BLACK )
        else                    bitmap.crop( adjusted_width, h,  anchor, Color.BLACK )
      else
        if (adjusted_width < h) bitmap.crop( adjusted_width, h,  anchor, Color.BLACK )
        else                    bitmap.crop( w, adjusted_height, anchor, Color.BLACK )
      endIf

      return bitmap
endClass


class CmdSetAnchor( xy:XY ) : Command
  METHODS
    method call( bitmap:Bitmap )->Bitmap
      println "  anchor ($,$)" (xy.x.format(".3"),xy.y.format(".3"))
      Command.anchor_x = xy.x
      Command.anchor_y = xy.y
      return bitmap
endClass


class CmdSave : Command
  GLOBAL PROPERTIES
    sequence_number = 0

  PROPERTIES
    pattern    : String
    seq        : String
    seq_format : String

  METHODS
    method init( pattern )
      seq = pattern.extract_string( "*{$(I)}*" )
      if (seq)
        sequence_number = seq->Int32
        seq_format = "0"+(seq.count)
        seq = "{$}" (seq)
      endIf

    method call( bitmap:Bitmap )->Bitmap
      local filepath = pattern

      if (seq)
        filepath .= replacing( seq, sequence_number.format(seq_format) )
        ++sequence_number
      endIf

      filepath .= replacing( "{filepath}", bitmap.filepath )
      filepath .= replacing( "{filename}", File.filename(bitmap.filepath) )
      filepath .= replacing( "{name}",     File.filename(bitmap.filepath).before_last('.') )
      filepath .= replacing( "{ext}",      File.extension(bitmap.filepath) )
      filepath .= replacing( "{path}",     File.path(bitmap.filepath) )
      filepath .= replacing( "{w}",        bitmap.width->String )
      filepath .= replacing( "{h}",        bitmap.height->String )

      println "  -> $ [$x$]" (filepath,bitmap.width,bitmap.height)
      return bitmap
endClass

class CmdSaveReplace : Command
  METHODS
    method call( bitmap:Bitmap )->Bitmap
      local filepath = bitmap.filepath
      println "  -> $ [$x$]" (filepath,bitmap.width,bitmap.height)
      return bitmap
endClass


